
# Recovery 전략  
[Ref](https://d2.naver.com/helloworld/407507)  

## 흐름  

1. Recovery를 위하여 REDO log와 UNDO log를 유지한다.  
2. REDO, UNDO 로그를 이해하기 위해서 STEAL 과 FORCE 정책을 알아야 한다.  
3. STEAL 과 FORCE 정책을 이해하기 위해서 Buffer Cache를 이해해야 한다.  


### 1. Buffer cache  
![image](https://user-images.githubusercontent.com/62331555/81323481-69274500-90d0-11ea-869a-c3fa1b3b0db6.png)  

* Disk I/O를 최소화하기 위하여, DBMS는 자체적인 메모리 공간인 **Buffer cache**를 가지고 있다.  
* Buffer cache와 Disk 사이의 데이터 전송은 **페이지(4KB)** 단위로 이뤄진다.  
* Buffer pool이 다 차게 되면 **eviction**을 수행한다.  

##  

### 2. 버퍼 캐시 관리 정책  
* 버퍼 캐시는 제한된 크기를 가진다.  
그렇기에 꽉 차게 되면 **버퍼 교체 알고리즘**을 기반으로 메모리 상의 **Dirty page**를 디스크에 써야 한다.  

* **버퍼 캐시**의 데이터를 **언제 디스크에 쓸 지**에 대한 정책을 **STEAL**이라고 한다.  

1. **STEAL** : (깔짝될 수 있음) 트랜젝션 도중 언제든지 디스크에 Dirty page를 쓸 수 있다.  
2. **No-STEAL** : (안된다.) 버퍼 풀에 모았다가 커밋되면 한번에 써야 한다.  

* NO-STEAL은 모두 버퍼 캐시에 모으기에, 메모리 크기 제한으로 인해 비현실적이다.  
그렇기에 STEAL을 대게 채택한다. 그렇다면 트랜젝션 도중에 Disk에 쓰일 수 있기에 필연적으로 **UNDO** 복구가 필요해지는 것이다.  


* **커밋한 후** 즉시 디스크에 쓸지, 혹은 나중으로 미룰지에 대한 정책  

1. **FORCE** : 커밋이 되면, 그 자리에서 바로 디스크에 쓴다.  
2. **NO-FORCE** : 커밋이 되더라도, 바로 쓰지 않아도 된다.  

* 대게 DBMS는 **NO-FORCE** 정책을 채택한다. - 빈번한 I/O를 피하기 위해서.  

##  

### 3. UNDO 와 REDO 로그  
* DBMS가 cache buffer 정책을 **STEAL**과 **NO-FORCE**로 채택한 경우 **UNDO**와 **REDO** 로그 유지는 필연적인 것이다.  


#### 로그  
* 로그는 로그 레코드의 연속으로 이뤄지며, DB에서 발생하는 모든 갱신 작업을 기록한다.  

* 로그의 레코드 : (구현체에 따라 다름) 로그의 레코드가 **변경 전의 이미지**와 **변경 후의 이미지** 둘 다 갖도록 구현할 수도 있다.  
이 때,  
UNDO 복구 발생 시 **이전 이미지**를 반영하여 복구하고  
REDO 복구 발생 시 **이후 이미지**를 반영하여 복구할 수 있다.  

##  

### 4. WAL  
* Write-Ahead Log  

* WAL 정책은 무슨 데이터든 **디스크에 적기 전에 로그에 먼저 적어야 한다**는 정책이다.  

* 로그 역시 메모리 상의 **로그 버퍼**를 경유하여 **안전한 저장 매체**에 적힌다.  
* 로그 버퍼가 바로 디스크에 쓰이기 위하여 **fsync(2)**를 사용한다.  
* fsync의 반환을 기다려야 하기에 느리다...?  

![image](https://user-images.githubusercontent.com/62331555/81323481-69274500-90d0-11ea-869a-c3fa1b3b0db6.png)  























































